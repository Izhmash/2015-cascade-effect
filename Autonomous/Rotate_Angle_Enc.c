#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//wheel seperation: 17 1/16"

int getWheelAngle(tMotor motorT, int ticksPerRev);
float getWheelDistM(tMotor motorT, int ticksPerRev, int radiusM);
float getWheelDistIn(tMotor motorT, int ticksPerRev, int radiusIn);
float getRobotAngle(float wheelSeperation, tMotor motorT, int ticksPerRev, int radiusM);

const unsigned byte radIn = 2;
const float radM = 0.00508;
const float wheelSep = (17 + (1/16)) * 2.54;
const short ticks = 1120;

// Test program for spinning a robot with encoders. Assumes 2 wheels

task main()
{
	while (true) {
		nxtDisplayCenteredBigTextLine(2, "%f", getRobotAngle(wheelSep, motor1, ticks, radM));
		while(nNxtButtonPressed == 1)
		{
			motor[motor1] = 100;
			motor[motor2] = -100;
			nxtDisplayCenteredBigTextLine(2, "%d", nMotorEncoder[motor1]);
			nxtDisplayCenteredBigTextLine(5, "%d", nMotorEncoder[motor2]);
		}
		while(nNxtButtonPressed == 2)
		{
			motor[motor1] = -100;
			motor[motor2] = 100;
			nxtDisplayCenteredBigTextLine(2, "%d", nMotorEncoder[motor1]);
			nxtDisplayCenteredBigTextLine(5, "%d", nMotorEncoder[motor2]);
		}
	}
}

int getWheelAngle(tMotor motorT, int ticksPerRev) {
	//angle = (360 deg) / (max encoder ticks per rev)
	return nMotorEncoder[motorT] * 360 / ticksPerRev;
}

float getWheelDistM(tMotor motorT, int ticksPerRev, int radiusM) {
	//s = angle * r
	return nMotorEncoder[motorT] * getWheelAngle(motorT, ticksPerRev) * radM;
}

float getWheelDistIn(tMotor motorT, int ticksPerRev, int radiusIn) {
	//s = angle * r
	return nMotorEncoder[motorT] * getWheelAngle(motorT, ticksPerRev) * radIn;
}

//using SI units
float getRobotAngle(float wheelSeperation, tMotor motorT, int ticksPerRev, int radiusM) {
	return getWheelDistM(motorT, ticksPerRev, radM) / (0.5 * wheelSeperation);
}
