#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * Author: Ian Ballou
 * An API for determining angle information from encoder values
 */

//wheel seperation: 17 1/16"

float getWheelAngleRad(tMotor motorT, int ticksPerRev);
float getWheelAngleDeg(tMotor motorT, int ticksPerRev);
float getWheelDistM(tMotor motorT, int ticksPerRev, float radiusM);
float getWheelDistIn(tMotor motorT, int ticksPerRev, float radiusIn);
float getRobotAngleRad(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation);
float getRobotAngleDeg(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation);
void rotateAngleRad(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation, float angle);
void rotateAngleDeg(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation, float angle);

const unsigned byte radIn = 2;
const float radM = 0.0508;
const float wheelSep = (17 + (1/16)) * 2.54 / 100;
const short ticks = 1120;

// Test program for spinning a robot with encoders. Assumes 2 wheels

task main()
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	while (true) {
		if (nNxtButtonPressed == 3) {
			rotateAngleDeg(motorL, ticks, radM, wheelSep, -45);
		}
		nxtDisplayCenteredTextLine(3, "%f", getRobotAngleDeg(motorL, ticks, radM, wheelSep));
		while(nNxtButtonPressed == 1) {
			nxtDisplayCenteredTextLine(3, "%f", getRobotAngleDeg(motorL, ticks, radM, wheelSep));
			motor[motorL] = 100;
			motor[motorR] = -100;
			//nxtDisplayCenteredTextLine(6, "%d", nMotorEncoder[motor1]);
			//nxtDisplayCenteredTextLine(7, "%d", nMotorEncoder[motor2]);
			//nxtDisplayCenteredTextLine(5, "%f", getWheelAngleRad(motorL, ticks));
			nxtDisplayCenteredTextLine(5, "%f", getWheelDistM(motorL, ticks, radM));
		}
		while (nNxtButtonPressed == 2) {
			nxtDisplayCenteredTextLine(3, "%f", getRobotAngleDeg(motorL, ticks, radM, wheelSep));
			motor[motorL] = -100;
			motor[motorR] = 100;
			//nxtDisplayCenteredTextLine(6, "%d", nMotorEncoder[motor1]);
			//nxtDisplayCenteredTextLine(7, "%d", nMotorEncoder[motor2]);
			//nxtDisplayCenteredTextLine(5, "%f", getWheelAngleRad(motorL, ticks));
			nxtDisplayCenteredTextLine(5, "%f", getWheelDistM(motorL, ticks, radM));
		}
		motor[motorL] = 0;
		motor[motorR] = 0;
	}
}

float getWheelAngleRad(tMotor motorT, int ticksPerRev) {
	//angle = (2PI Radians) / (max encoder ticks per rev)
	return nMotorEncoder[motorT] * 2 * PI / ticksPerRev;
}

float getWheelAngleDeg(tMotor motorT, int ticksPerRev) {
	//angle = (2PI Radians) / (max encoder ticks per rev)
	return nMotorEncoder[motorT] * 360 / ticksPerRev;
}

float getWheelDistM(tMotor motorT, int ticksPerRev, float radiusM) {
	//s = angle * r
	return getWheelAngleRad(motorT, ticksPerRev) * radM;
}

float getWheelDistIn(tMotor motorT, int ticksPerRev, float radiusIn) {
	//s = angle * r
	return getWheelAngleRad(motorT, ticksPerRev) * radIn;
}

//using SI units
float getRobotAngleRad(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation) {
	//angle = s / r
	return getWheelDistM(motorT, ticksPerRev, radM) / (0.5 * wheelSeperation);
}

float getRobotAngleDeg(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation) {
	//angle = s / r
	return getRobotAngleRad(motorT, ticksPerRev, radM, wheelSeperation) * 180 / PI;
}

//wrong direction?
void rotateAngleRad(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation, float angle) {
	while(getRobotAngleRad(motorT, ticksPerRev, radM, wheelSeperation) < angle) {
		//turn left
		motor[motorL] = 20;
		motor[motorR] = 20;
	}
	while(getRobotAngleRad(motorT, ticksPerRev, radM, wheelSeperation) > angle) {
		//turn right
		motor[motorL] = -20;
		motor[motorR] = -20;
	}
}

//wrong direction?
void rotateAngleDeg(tMotor motorT, int ticksPerRev, int radiusM, float wheelSeperation, float angle) {
	while(getRobotAngleDeg(motorT, ticksPerRev, radM, wheelSeperation) < angle) {
		//turn left
		motor[motorL] = 20;
		motor[motorR] = 20;
	}
	while(getRobotAngleDeg(motorT, ticksPerRev, radM, wheelSeperation) > angle) {
		//turn right
		motor[motorL] = -20;
		motor[motorR] = -20;
	}
}
