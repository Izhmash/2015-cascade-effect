#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTGYRO,              sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     leftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
 *
 */
#include "hitechnic-gyro.h"

task findHeading();
void rotateAngle(int a);

float gyroRaw;
float tempW;
float avgW;
float angle;
float count;
float heading;


task main()
{
	nVolume = 2;
	int reference = 0;
	HTGYROstartCal(HTGYRO);
	delay(1000);
	startTask(findHeading);
	rotateAngle(90);
	/*while (true) {
		playImmediateTone(1000, 1);
		playImmediateTone(0, 10);
		delay((abs(heading - reference) * 8) + 100);
		if(nNxtButtonPressed == 3) {
 			reference = heading;
		}
	}*/
}

/*
 * Rotate a certain angle in degrees
 */
void rotateAngle(int a)
{
	int reference = heading;
	if (a > 0) {
		while (heading < reference + a) {
			//turn right
			motor[leftMotor] = 20;
			motor[rightMotor] = 20;
		  playTone(996, 5);
		}
		motor[leftMotor] = 0;
		motor[rightMotor] = 0;
		return;

	} else {
		while (heading > reference + a) {
			//turn left
			motor[leftMotor] = -20;
			motor[rightMotor] = -20;
		  playTone(996, 5);
		}
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

task findHeading()
{
	int safetyValue = 1;  //value to protect against poor calibration
	heading = 0;
	gyroRaw = 0;
	avgW = 0;
	//angle = 0;
	count = 0;
	HTGYROstartCal(HTGYRO);
	while (true) {
		gyroRaw = HTGYROreadRot(HTGYRO);
		tempW = 0;
		avgW = 0;
		count = 0;
		//angle = 0;
		if (abs(gyroRaw) > safetyValue) {
			time1[T1] = 0;
			while (abs(gyroRaw) > safetyValue && time1[T1] < 25) {
				gyroRaw = HTGYROreadRot(HTGYRO);
				tempW += gyroRaw;
				count++;
			}
			avgW = (tempW / count);
			angle = avgW*time1[T1]/1000;  //delta theta = avg_w*t
			time1[T1] = 0;
		}
		heading += angle;
		angle = 0;
		nxtDisplayCenteredBigTextLine(2, "%d", heading);
		nxtDisplayCenteredBigTextLine(4, "%d", gyroRaw);

		delay(1);
	}
}
